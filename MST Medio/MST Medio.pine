//@version=6
// ─────────────────────────────────────────────────────────────────────────────
// Indicator : MST Medio
// Version   : v0.2
// Author    : MTS
// Based on  : PA Break v0.7.0
// Purpose   : Detect HH/LL breakouts → wait for CLOSE vượt W1 peak (confirm)
//             → then wait for RETEST at SH/SL (Entry = đỉnh/đáy cũ).
//             SH = sh0 (đỉnh cũ bị phá), W1 peak = sh1 (đỉnh mới).
// Notes     : Works on all timeframes. Non-repainting (uses confirmed pivots).
//             Break = HH/LL → close vượt W1 → retest → entry signal.
// ─────────────────────────────────────────────────────────────────────────────
indicator(
     title      = "MST Medio v0.2",
     shorttitle = "MST Medio",
     overlay    = true,
     max_labels_count = 500,
     max_lines_count  = 500,
     max_boxes_count  = 500
)

// ============================================================================
// A) INPUTS
// ============================================================================
string GRP_CORE  = "Core"
string GRP_STYLE = "Style"

pivotLen   = input.int(5,   "Pivot Lookback", minval = 2, maxval = 50, group = GRP_CORE,
             tooltip = "Number of bars left/right to confirm a Swing High/Low.")
breakMult  = input.float(0.25, "Break Strength (x Swing Range)", minval = 0, step = 0.25, group = GRP_CORE,
             tooltip = "Break distance must be >= breakMult x previous swing range. 0 = filter OFF.")
impulseMult = input.float(1.5, "Impulse Body (x Avg Body)", minval = 0, step = 0.25, group = GRP_CORE,
             tooltip = "Nến break phải có thân >= impulseMult x body trung bình. 0 = OFF.")

// Style
showSwings     = input.bool(false, "Show Swing Points",     group = GRP_STYLE)
showBreakLabel = input.bool(true,  "Show Break Labels",     group = GRP_STYLE)
showBreakLine  = input.bool(true,  "Show Break Lines",      group = GRP_STYLE)

colBreakUp   = input.color(color.new(color.green, 0),  "Break UP Label",     group = GRP_STYLE)
colBreakDown = input.color(color.new(color.red, 0),    "Break DOWN Label",   group = GRP_STYLE)
colEntryBuy  = input.color(color.new(color.blue, 0),   "Entry Buy Color",    group = GRP_STYLE)
colEntrySell = input.color(color.new(#ff69b4, 0),      "Entry Sell Color",   group = GRP_STYLE)
colSL        = input.color(color.new(color.yellow, 0), "SL Color",           group = GRP_STYLE)
colSwingHigh = input.color(color.new(color.orange, 40), "Swing High Color",  group = GRP_STYLE)
colSwingLow  = input.color(color.new(color.blue, 40),   "Swing Low Color",   group = GRP_STYLE)

// ============================================================================
// B) CORE LOGIC
// ============================================================================

// -- Swing Detection --
swingHigh = ta.pivothigh(high, pivotLen, pivotLen)
swingLow  = ta.pivotlow(low,  pivotLen, pivotLen)

// -- Track Swing History --
var float sh1     = na      // Most recent Swing High
var float sh0     = na      // Previous Swing High
var int   sh1_idx = na
var int   sh0_idx = na

var float sl1     = na      // Most recent Swing Low
var float sl0     = na      // Previous Swing Low
var int   sl1_idx = na
var int   sl0_idx = na

var float slBeforeSH     = na   // Last SL before the most recent SH
var int   slBeforeSH_idx = na
var float shBeforeSL     = na   // Last SH before the most recent SL
var int   shBeforeSL_idx = na

// Track highest SH / lowest SL since last break (for true HH/LL detection)
var float shRecentMax     = na   // Highest SH since last valid LL break
var float slRecentMin     = na   // Lowest SL since last valid HH break

if not na(swingLow)
    sl0     := sl1
    sl0_idx := sl1_idx
    sl1     := swingLow
    sl1_idx := bar_index - pivotLen
    // Track lowest SL
    if na(slRecentMin) or swingLow < slRecentMin
        slRecentMin := swingLow

if not na(swingHigh)
    slBeforeSH     := sl1
    slBeforeSH_idx := sl1_idx
    sh0     := sh1
    sh0_idx := sh1_idx
    sh1     := swingHigh
    sh1_idx := bar_index - pivotLen
    // Track highest SH
    if na(shRecentMax) or swingHigh > shRecentMax
        shRecentMax := swingHigh

if not na(swingLow)
    shBeforeSL     := sh1
    shBeforeSL_idx := sh1_idx

// -- HH / LL Detection (true HH: must exceed ALL recent SH, not just sh0) --
bool isNewHH = not na(swingHigh) and not na(sh0) and sh1 > sh0 and sh1 >= shRecentMax
bool isNewLL = not na(swingLow)  and not na(sl0) and sl1 < sl0 and sl1 <= slRecentMin

// -- Impulse Body Filter (nến break phải có thân dài) --
// Tìm nến đầu tiên CLOSE vượt đỉnh/đáy cũ, check body >= impulseMult × avg
float _avgBody = ta.sma(math.abs(close - open), 20)

if isNewHH and impulseMult > 0
    int _fromBar = bar_index - sh0_idx   // sh0 position (lookback)
    int _toBar   = pivotLen               // sh1 position (lookback)
    bool _found  = false
    for i = _fromBar to _toBar
        if close[i] > sh0
            // This is the FIRST candle closing above → must be impulse
            _found := math.abs(close[i] - open[i]) >= impulseMult * _avgBody
            break  // Only check the FIRST one
    if not _found
        isNewHH := false

if isNewLL and impulseMult > 0
    int _fromBar = bar_index - sl0_idx
    int _toBar   = pivotLen
    bool _found  = false
    for i = _fromBar to _toBar
        if close[i] < sl0
            _found := math.abs(close[i] - open[i]) >= impulseMult * _avgBody
            break  // Only check the FIRST one
    if not _found
        isNewLL := false

// -- Break Strength Filter (optional, default OFF) --
bool rawBreakUp  = false
bool rawBreakDown = false

if isNewHH and not na(slBeforeSH)
    if breakMult <= 0
        rawBreakUp := true
    else
        float swR = sh0 - slBeforeSH
        float brD = sh1 - sh0
        if swR > 0 and brD >= swR * breakMult
            rawBreakUp := true

if isNewLL and not na(shBeforeSL)
    if breakMult <= 0
        rawBreakDown := true
    else
        float swR = shBeforeSL - sl0
        float brD = sl0 - sl1
        if swR > 0 and brD >= swR * breakMult
            rawBreakDown := true

// ============================================================================
// C) 3-PHASE CONFIRMATION: BREAK → CONFIRM → RETEST ENTRY
// ============================================================================
// Phương pháp:
//   1. Tìm SH (đỉnh cũ = sh0). Sau SH có break lớn tạo HH (sh1 > sh0).
//      → sh1 = đỉnh W1 (W1 peak), sh0 = SH = Entry level
//   2. Phase 1: Chờ giá pullback rồi CLOSE vượt W1 peak (sh1) → Confirm
//      → Cancel nếu chân sóng W1 (low) chạm SH (sh0) → phá cấu trúc
//      → Cancel nếu giá chạm SL
//   3. Phase 2: Chờ retest tại SH (sh0) → Entry
//      → Cancel nếu giá chạm SL
//
// SELL: ngược lại — SL (đáy cũ = sl0), LL (sl1), W1 trough = sl1
//
// States:
//   0 = idle
//   1 = phase 1: chờ confirm BUY (close > W1 peak)
//   2 = phase 2: chờ retest BUY (price <= Entry)
//  -1 = phase 1: chờ confirm SELL (close < W1 trough)
//  -2 = phase 2: chờ retest SELL (price >= Entry)

var int   pendingState   = 0
var float pendBreakPoint = na   // SH (sh0) or SL (sl0) = Entry level
var float pendW1Peak     = na   // W1 peak (sh1) or W1 trough (sl1) = mốc cần vượt
var float pendSL         = na   // Stop Loss level
var int   pendSL_idx     = na
var int   pendBreak_idx  = na

// Confirm tracking
var int   waveConfBar    = na   // bar_index when confirmed
var float waveConfHigh   = na   // high of confirm bar
var float waveConfLow    = na   // low of confirm bar

// Candle direction
bool isBullish = close >= open

// Confirmed signals (for plotting and alerts)
bool confirmedBuy  = false
bool confirmedSell = false

// Save confirmed values for drawing
float confEntry      = na
float confSL         = na
int   confSL_idx     = na
int   confBreak_idx  = na
float confBreakPt    = na
int   confWaveBar    = na  // bar where wave was confirmed
float confWaveHigh   = na  // high of wave confirm bar
float confWaveLow    = na  // low of wave confirm bar

// -- Phase 2: Retest at Entry (sh0 for BUY, sl0 for SELL) --
if pendingState == 2 and not na(pendBreakPoint)
    // SL invalidation
    if not na(pendSL) and low <= pendSL
        pendingState := 0
    else if low <= pendBreakPoint
        confirmedBuy  := true
        confEntry     := pendBreakPoint
        confSL        := pendSL
        confSL_idx    := pendSL_idx
        confBreak_idx := pendBreak_idx
        confBreakPt   := pendBreakPoint
        confWaveBar   := waveConfBar
        confWaveHigh  := waveConfHigh
        confWaveLow   := waveConfLow
        pendingState  := 0

if pendingState == -2 and not na(pendBreakPoint)
    // SL invalidation
    if not na(pendSL) and high >= pendSL
        pendingState := 0
    else if high >= pendBreakPoint
        confirmedSell := true
        confEntry     := pendBreakPoint
        confSL        := pendSL
        confSL_idx    := pendSL_idx
        confBreak_idx := pendBreak_idx
        confBreakPt   := pendBreakPoint
        confWaveBar   := waveConfBar
        confWaveHigh  := waveConfHigh
        confWaveLow   := waveConfLow
        pendingState  := 0

// -- Phase 1: Wait for CLOSE > W1 peak (BUY) or CLOSE < W1 trough (SELL) --
if pendingState == 1
    // BUY: chờ close > W1 peak (sh1)
    if not na(pendSL) and low <= pendSL
        // SL hit → cancel
        pendingState := 0
    else if not na(pendBreakPoint) and low <= pendBreakPoint
        // Chân sóng W1 về lại SH → phá cấu trúc → cancel
        pendingState := 0
    else if not na(pendW1Peak) and close > pendW1Peak
        // Close vượt W1 peak → Confirm! → move to retest phase
        pendingState := 2
        waveConfBar  := bar_index
        waveConfHigh := high
        waveConfLow  := low

if pendingState == -1
    // SELL: chờ close < W1 trough (sl1)
    if not na(pendSL) and high >= pendSL
        // SL hit → cancel
        pendingState := 0
    else if not na(pendBreakPoint) and high >= pendBreakPoint
        // Chân sóng W1 về lại SL (Entry) → phá cấu trúc → cancel
        pendingState := 0
    else if not na(pendW1Peak) and close < pendW1Peak
        // Close vượt W1 trough → Confirm! → move to retest phase
        pendingState := -2
        waveConfBar  := bar_index
        waveConfHigh := high
        waveConfLow  := low

// -- New raw break → start tracking --
// SH = sh0 (đỉnh cũ = Entry), W1 peak = sh1 (đỉnh mới)
if rawBreakUp and pendingState != 2
    pendingState   := 1
    pendBreakPoint := sh0       // SH = Entry level
    pendW1Peak     := sh1       // W1 peak = mốc cần vượt
    pendSL         := slBeforeSH
    pendSL_idx     := slBeforeSH_idx
    pendBreak_idx  := sh0_idx   // Entry line starts from sh0
    // Reset recent tracking (new cycle starts after break)
    shRecentMax   := sh1
    slRecentMin   := na
    // Retroactively scan bars from SH candle to current bar
    // Check if any bar already closed > W1 peak, or if low <= Entry (cancel)
    for i = pivotLen - 1 to 0
        if pendingState != 1
            break
        float rHigh  = high[i]
        float rLow   = low[i]
        float rClose = close[i]
        // SL check
        if not na(pendSL) and rLow <= pendSL
            pendingState := 0
            break
        // Chân sóng W1 về lại SH → cancel
        if not na(pendBreakPoint) and rLow <= pendBreakPoint
            pendingState := 0
            break
        // Confirm: close > W1 peak
        if not na(pendW1Peak) and rClose > pendW1Peak
            pendingState := 2
            waveConfBar  := bar_index - i
            waveConfHigh := rHigh
            waveConfLow  := rLow
            break

// SL (đáy cũ = Entry), W1 trough = sl1 (đáy mới)
if rawBreakDown and pendingState != -2
    pendingState   := -1
    pendBreakPoint := sl0       // SL = Entry level
    pendW1Peak     := sl1       // W1 trough = mốc cần vượt (xuống)
    pendSL         := shBeforeSL
    pendSL_idx     := shBeforeSL_idx
    pendBreak_idx  := sl0_idx   // Entry line starts from sl0
    // Reset recent tracking (new cycle starts after break)
    slRecentMin   := sl1
    shRecentMax   := na
    // Retroactively scan bars from SL candle to current bar
    for i = pivotLen - 1 to 0
        if pendingState != -1
            break
        float rHigh  = high[i]
        float rLow   = low[i]
        float rClose = close[i]
        // SL check
        if not na(pendSL) and rHigh >= pendSL
            pendingState := 0
            break
        // Chân sóng W1 về lại SL (Entry) → cancel
        if not na(pendBreakPoint) and rHigh >= pendBreakPoint
            pendingState := 0
            break
        // Confirm: close < W1 trough
        if not na(pendW1Peak) and rClose < pendW1Peak
            pendingState := -2
            waveConfBar  := bar_index - i
            waveConfHigh := rHigh
            waveConfLow  := rLow
            break

// ============================================================================
// D) PLOTTING / UI
// ============================================================================

// -- Swing Points --
plotshape(showSwings and not na(swingHigh), title = "Swing High",
     style = shape.triangledown, location = location.abovebar,
     color = colSwingHigh, offset = -pivotLen, size = size.tiny)

plotshape(showSwings and not na(swingLow), title = "Swing Low",
     style = shape.triangleup, location = location.belowbar,
     color = colSwingLow, offset = -pivotLen, size = size.tiny)

// -- Persistent Lines --
var line  activeEntryLine = na
var line  activeSLLine    = na

f_terminateLines() =>
    if not na(activeEntryLine)
        line.set_x2(activeEntryLine, bar_index)
    if not na(activeSLLine)
        line.set_x2(activeSLLine, bar_index)

// -- Confirmed BUY Retest --
if confirmedBuy
    if showBreakLine
        f_terminateLines()
        activeEntryLine := line.new(confBreak_idx, confEntry, bar_index, confEntry,
             xloc = xloc.bar_index, color = colEntryBuy,
             style = line.style_dashed, width = 1)
        activeSLLine := line.new(confSL_idx, confSL, bar_index, confSL,
             xloc = xloc.bar_index, color = colSL,
             style = line.style_dashed, width = 1)
        // Entry & SL labels on lines
        label.new(bar_index, confEntry, "Entry",
             xloc = xloc.bar_index, yloc = yloc.price,
             style = label.style_label_left, color = colEntryBuy,
             textcolor = color.white, size = size.tiny)
        label.new(bar_index, confSL, "SL",
             xloc = xloc.bar_index, yloc = yloc.price,
             style = label.style_label_left, color = colSL,
             textcolor = color.white, size = size.tiny)

    if showBreakLabel
        label.new(confWaveBar, confWaveHigh, "Confirm Break",
             xloc = xloc.bar_index, yloc = yloc.price,
             style = label.style_label_down, color = colBreakUp,
             textcolor = color.white, size = size.tiny)

// -- Confirmed SELL Retest --
if confirmedSell
    if showBreakLine
        f_terminateLines()
        activeEntryLine := line.new(confBreak_idx, confEntry, bar_index, confEntry,
             xloc = xloc.bar_index, color = colEntrySell,
             style = line.style_dashed, width = 1)
        activeSLLine := line.new(confSL_idx, confSL, bar_index, confSL,
             xloc = xloc.bar_index, color = colSL,
             style = line.style_dashed, width = 1)
        // Entry & SL labels on lines
        label.new(bar_index, confEntry, "Entry",
             xloc = xloc.bar_index, yloc = yloc.price,
             style = label.style_label_left, color = colEntrySell,
             textcolor = color.white, size = size.tiny)
        label.new(bar_index, confSL, "SL",
             xloc = xloc.bar_index, yloc = yloc.price,
             style = label.style_label_left, color = colSL,
             textcolor = color.white, size = size.tiny)

    if showBreakLabel
        label.new(confWaveBar, confWaveLow, "Confirm Break",
             xloc = xloc.bar_index, yloc = yloc.price,
             style = label.style_label_up, color = colBreakDown,
             textcolor = color.white, size = size.tiny)

// -- Extend active lines to the right every bar --
if not na(activeEntryLine)
    line.set_x2(activeEntryLine, bar_index)
if not na(activeSLLine)
    line.set_x2(activeSLLine, bar_index)

// ============================================================================
// E) ALERTS
// ============================================================================
alertcondition(confirmedBuy,                    title = "Wave Buy",    message = "MST Medio: BUY wave+retest entry on {{ticker}} @ {{close}}")
alertcondition(confirmedSell,                   title = "Wave Sell",   message = "MST Medio: SELL wave+retest entry on {{ticker}} @ {{close}}")
alertcondition(confirmedBuy or confirmedSell,   title = "Any Signal",  message = "MST Medio: Wave+retest entry on {{ticker}} @ {{close}}")
