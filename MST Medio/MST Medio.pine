//@version=6
// ─────────────────────────────────────────────────────────────────────────────
// Indicator : MST Medio
// Version   : v1.0
// Author    : Tuan
// Purpose   : Detect HH/LL breakouts → wait for CLOSE beyond W1 peak (confirm)
//             → then wait for RETEST at SH/SL (Entry = old high/low).
//             3-Phase Confirmation: Break → Confirm → Retest → Signal
// Notes     : Works on all timeframes. Non-repainting (uses confirmed pivots).
// ─────────────────────────────────────────────────────────────────────────────
indicator(
     title      = "MST Medio v1.0",
     shorttitle = "MST Medio",
     overlay    = true,
     max_labels_count = 500,
     max_lines_count  = 500,
     max_boxes_count  = 500
)

// ============================================================================
// A) INPUTS
// ============================================================================
string GRP_SIGNAL = "Signal Detection"
string GRP_VIS    = "Visual"

pivotLen   = input.int(5,   "Pivot Lookback", minval = 2, maxval = 50, group = GRP_SIGNAL,
             tooltip = "Number of bars left and right to confirm a Swing High/Low pivot point.")
breakMult  = input.float(0.25, "Break Strength", minval = 0, step = 0.25, group = GRP_SIGNAL,
             tooltip = "Break distance must be ≥ breakMult × previous swing range. Set 0 to disable this filter.")
impulseMult = input.float(1.5, "Impulse Body Filter", minval = 0, step = 0.25, group = GRP_SIGNAL,
             tooltip = "The first candle closing beyond the old high/low must have body ≥ impulseMult × 20-bar average body. Set 0 to disable.")

// Visual
showSwings     = input.bool(false, "Show Swing Points",       group = GRP_VIS)
showBreakLabel = input.bool(true,  "Show Confirm Break Label", group = GRP_VIS,
                 tooltip = "Show '▲ Confirm Break' / '▼ Confirm Break' label at the wave confirmation candle.")
showBreakLine  = input.bool(true,  "Show Entry / SL / TP Lines", group = GRP_VIS,
                 tooltip = "Show dashed lines for Entry, Stop Loss, and Take Profit levels.")
showBoxes      = input.bool(true,  "Show Risk/Reward Zones",  group = GRP_VIS,
                 tooltip = "Show colored boxes: red zone (Entry→SL) and green zone (Entry→TP).")

showPending    = input.bool(true,  "Show Pending State",      group = GRP_VIS,
                 tooltip = "Show Entry line and W1 Peak/Trough line while waiting for confirmation.")

colBreakUp   = input.color(color.new(#26a69a, 0),  "Break UP Color",     group = GRP_VIS)
colBreakDown = input.color(color.new(#ef5350, 0),   "Break DOWN Color",   group = GRP_VIS)
colEntryBuy  = input.color(color.new(#2196F3, 0),   "Entry Buy Color",    group = GRP_VIS)
colEntrySell = input.color(color.new(#ff69b4, 0),   "Entry Sell Color",   group = GRP_VIS)
colSL        = input.color(color.new(#FF9800, 0),   "Stop Loss Color",    group = GRP_VIS)
colTP        = input.color(color.new(#4CAF50, 0),   "Take Profit Color",  group = GRP_VIS)
colSwingHigh = input.color(color.new(color.orange, 40), "Swing High Color",  group = GRP_VIS)
colSwingLow  = input.color(color.new(color.blue, 40),   "Swing Low Color",   group = GRP_VIS)

// ============================================================================
// B) CORE LOGIC
// ============================================================================

// -- Swing Detection --
swingHigh = ta.pivothigh(high, pivotLen, pivotLen)
swingLow  = ta.pivotlow(low,  pivotLen, pivotLen)

// -- Track Swing History --
var float sh1     = na      // Most recent Swing High
var float sh0     = na      // Previous Swing High
var int   sh1_idx = na
var int   sh0_idx = na

var float sl1     = na      // Most recent Swing Low
var float sl0     = na      // Previous Swing Low
var int   sl1_idx = na
var int   sl0_idx = na

var float slBeforeSH     = na   // Last SL before the most recent SH
var int   slBeforeSH_idx = na
var float shBeforeSL     = na   // Last SH before the most recent SL
var int   shBeforeSL_idx = na


if not na(swingLow)
    sl0     := sl1
    sl0_idx := sl1_idx
    sl1     := swingLow
    sl1_idx := bar_index - pivotLen

if not na(swingHigh)
    slBeforeSH     := sl1
    slBeforeSH_idx := sl1_idx
    sh0     := sh1
    sh0_idx := sh1_idx
    sh1     := swingHigh
    sh1_idx := bar_index - pivotLen

if not na(swingLow)
    shBeforeSL     := sh1
    shBeforeSL_idx := sh1_idx

// -- HH / LL Detection --
bool isNewHH = not na(swingHigh) and not na(sh0) and sh1 > sh0
bool isNewLL = not na(swingLow)  and not na(sl0) and sl1 < sl0

// -- Impulse Body Filter (nến break phải có thân dài) --
// Tìm nến đầu tiên CLOSE vượt đỉnh/đáy cũ, check body >= impulseMult × avg
float _avgBody = ta.sma(math.abs(close - open), 20)

if isNewHH and impulseMult > 0
    int _fromBar = bar_index - sh0_idx   // sh0 position (lookback)
    int _toBar   = pivotLen               // sh1 position (lookback)
    bool _found  = false
    for i = _fromBar to _toBar
        if close[i] > sh0
            // This is the FIRST candle closing above → must be impulse
            _found := math.abs(close[i] - open[i]) >= impulseMult * _avgBody
            break  // Only check the FIRST one
    if not _found
        isNewHH := false

if isNewLL and impulseMult > 0
    int _fromBar = bar_index - sl0_idx
    int _toBar   = pivotLen
    bool _found  = false
    for i = _fromBar to _toBar
        if close[i] < sl0
            _found := math.abs(close[i] - open[i]) >= impulseMult * _avgBody
            break  // Only check the FIRST one
    if not _found
        isNewLL := false

// -- Break Strength Filter (optional, default OFF) --
bool rawBreakUp  = false
bool rawBreakDown = false

if isNewHH and not na(slBeforeSH)
    if breakMult <= 0
        rawBreakUp := true
    else
        float swR = sh0 - slBeforeSH
        float brD = sh1 - sh0
        if swR > 0 and brD >= swR * breakMult
            rawBreakUp := true

if isNewLL and not na(shBeforeSL)
    if breakMult <= 0
        rawBreakDown := true
    else
        float swR = shBeforeSL - sl0
        float brD = sl0 - sl1
        if swR > 0 and brD >= swR * breakMult
            rawBreakDown := true

// ============================================================================
// C) 3-PHASE CONFIRMATION: BREAK → CONFIRM → RETEST ENTRY
// ============================================================================
// Phương pháp:
//   1. Tìm SH (đỉnh cũ = sh0). Sau SH có break lớn tạo HH (sh1 > sh0).
//      → W1 peak = highest high from break candle until first bearish candle
//        (sóng impulse đầu tiên, KHÔNG phải sh1 pivot high)
//      → sh0 = SH = Entry level
//   2. Phase 1: Chờ giá pullback rồi CLOSE vượt W1 peak → Confirm
//      → Cancel nếu chân sóng W1 (low) chạm SH (sh0) → phá cấu trúc
//      → Cancel nếu giá chạm SL
//   3. Phase 2: Chờ retest tại SH (sh0) → Entry
//      → Cancel nếu giá chạm SL
//      → Cancel nếu giá break W1 trough
//
// SELL: ngược lại — SL (đáy cũ = sl0), LL, W1 trough = first impulse wave low
//
// States:
//   0 = idle
//   1 = phase 1: chờ confirm BUY (close > W1 peak)
//   2 = phase 2: chờ retest BUY (price <= Entry)
//  -1 = phase 1: chờ confirm SELL (close < W1 trough)
//  -2 = phase 2: chờ retest SELL (price >= Entry)

var int   pendingState   = 0
var float pendBreakPoint = na   // SH (sh0) or SL (sl0) = Entry level
var float pendW1Peak     = na   // W1 peak (BUY) or W1 trough (SELL) = first impulse wave extreme
var float pendW1Trough   = na   // Đáy W1 (BUY) or Đỉnh W1 (SELL) — dùng để terminate lines
var float pendSL         = na   // Stop Loss level
var int   pendSL_idx     = na
var int   pendBreak_idx  = na

// Confirm tracking
var int   waveConfBar    = na   // bar_index when confirmed
var float waveConfHigh   = na   // high of confirm bar
var float waveConfLow    = na   // low of confirm bar

// Candle direction
bool isBullish = close >= open

// Confirmed signals (for plotting and alerts)
bool confirmedBuy  = false
bool confirmedSell = false

// Save confirmed values for drawing
float confEntry      = na
float confSL         = na
int   confSL_idx     = na
int   confBreak_idx  = na
float confBreakPt    = na
float confW1Peak     = na  // W1 peak value for TP reference
int   confWaveBar    = na  // bar where wave was confirmed
float confWaveHigh   = na  // high of wave confirm bar
float confWaveLow    = na  // low of wave confirm bar

// -- Persistent Lines (declared early for f_terminateLines) --
var line  activeEntryLine  = na
var line  activeSLLine     = na
var line  activeTPLine     = na
var float activeEntryPrice = na   // Entry price of last confirmed signal
var float activeTPPrice    = na   // TP price (confirm break high/low)
var int   activeSignalDir  = 0    // 1 = BUY, -1 = SELL

// -- Pending state lines --
var line  pendEntryLine    = na   // Dashed line at pending Entry level
var line  pendW1Line       = na   // Dashed line at W1 Peak/Trough level
var label pendPhaseLabel   = na   // "Phase 1" / "Phase 2" label

// -- Risk/Reward boxes --
var box   activeRiskBox    = na   // Entry → SL (red zone)
var box   activeRewardBox  = na   // Entry → TP (green zone)

f_terminateLines() =>
    if not na(activeEntryLine)
        line.set_x2(activeEntryLine, bar_index)
    if not na(activeSLLine)
        line.set_x2(activeSLLine, bar_index)
    if not na(activeTPLine)
        line.set_x2(activeTPLine, bar_index)

f_clearPending() =>
    if not na(pendEntryLine)
        line.delete(pendEntryLine)
    if not na(pendW1Line)
        line.delete(pendW1Line)
    if not na(pendPhaseLabel)
        label.delete(pendPhaseLabel)

f_clearBoxes() =>
    if not na(activeRiskBox)
        box.delete(activeRiskBox)
    if not na(activeRewardBox)
        box.delete(activeRewardBox)

// -- Post-signal Entry touch → terminate lines --
// Nến bất kỳ sau tín hiệu chạm Entry → kết thúc đường
if not na(activeEntryLine) and not na(activeEntryPrice) and activeSignalDir != 0
    bool _touchEntry = (activeSignalDir == 1 and low <= activeEntryPrice) or (activeSignalDir == -1 and high >= activeEntryPrice)
    if _touchEntry
        f_terminateLines()
        activeEntryLine  := na
        activeSLLine     := na
        activeTPLine     := na
        activeEntryPrice := na
        activeTPPrice    := na
        activeSignalDir  := 0

// -- Phase 2: Retest at Entry (sh0 for BUY, sl0 for SELL) --
if pendingState == 2 and not na(pendBreakPoint)
    // SL invalidation
    if not na(pendSL) and low <= pendSL
        pendingState := 0
        f_terminateLines()
        f_clearPending()
        activeEntryLine  := na
        activeSLLine     := na
        activeTPLine     := na
        activeEntryPrice := na
        activeTPPrice    := na
        activeSignalDir  := 0
        pendEntryLine    := na
        pendW1Line       := na
        pendPhaseLabel   := na
    else if low <= pendBreakPoint
        // Retest Entry → BUY signal!
        confirmedBuy  := true
        confEntry     := pendBreakPoint
        confSL        := pendSL
        confSL_idx    := pendSL_idx
        confBreak_idx := pendBreak_idx
        confBreakPt   := pendBreakPoint
        confW1Peak    := pendW1Peak
        confWaveBar   := waveConfBar
        confWaveHigh  := waveConfHigh
        confWaveLow   := waveConfLow
        pendingState  := 0
    // W1 trough invalidation — low chạm dưới chân sóng W1 → kết thúc
    else if not na(pendW1Trough) and low <= pendW1Trough
        pendingState := 0
        f_terminateLines()
        f_clearPending()
        activeEntryLine  := na
        activeSLLine     := na
        activeTPLine     := na
        activeEntryPrice := na
        activeTPPrice    := na
        activeSignalDir  := 0
        pendEntryLine    := na
        pendW1Line       := na
        pendPhaseLabel   := na

if pendingState == -2 and not na(pendBreakPoint)
    // SL invalidation
    if not na(pendSL) and high >= pendSL
        pendingState := 0
        f_terminateLines()
        f_clearPending()
        activeEntryLine  := na
        activeSLLine     := na
        activeTPLine     := na
        activeEntryPrice := na
        activeTPPrice    := na
        activeSignalDir  := 0
        pendEntryLine    := na
        pendW1Line       := na
        pendPhaseLabel   := na
    else if high >= pendBreakPoint
        // Retest Entry → SELL signal!
        confirmedSell := true
        confEntry     := pendBreakPoint
        confSL        := pendSL
        confSL_idx    := pendSL_idx
        confBreak_idx := pendBreak_idx
        confBreakPt   := pendBreakPoint
        confW1Peak    := pendW1Peak
        confWaveBar   := waveConfBar
        confWaveHigh  := waveConfHigh
        confWaveLow   := waveConfLow
        pendingState  := 0
    // W1 peak invalidation — high chạm trên đỉnh W1 (SELL) → kết thúc
    else if not na(pendW1Trough) and high >= pendW1Trough
        pendingState := 0
        f_terminateLines()
        f_clearPending()
        activeEntryLine  := na
        activeSLLine     := na
        activeTPLine     := na
        activeEntryPrice := na
        activeTPPrice    := na
        activeSignalDir  := 0
        pendEntryLine    := na
        pendW1Line       := na
        pendPhaseLabel   := na

// -- Phase 1: Wait for CLOSE > W1 peak (BUY) or CLOSE < W1 trough (SELL) --
if pendingState == 1
    // BUY: chờ close > W1 peak (sh1)
    // Track đáy W1 (lowest low từ break đến confirm)
    if na(pendW1Trough) or low < pendW1Trough
        pendW1Trough := low
    if not na(pendSL) and low <= pendSL
        // SL hit → cancel
        pendingState := 0
    else if not na(pendBreakPoint) and low <= pendBreakPoint
        // Chân sóng W1 về lại SH → phá cấu trúc → cancel
        pendingState := 0
    else if not na(pendW1Peak) and close > pendW1Peak
        // Close vượt W1 peak → Confirm! → move to retest phase
        pendingState := 2
        waveConfBar  := bar_index
        waveConfHigh := high
        waveConfLow  := low

if pendingState == -1
    // SELL: chờ close < W1 trough (sl1)
    // Track đỉnh W1 (highest high từ break đến confirm)
    if na(pendW1Trough) or high > pendW1Trough
        pendW1Trough := high
    if not na(pendSL) and high >= pendSL
        // SL hit → cancel
        pendingState := 0
    else if not na(pendBreakPoint) and high >= pendBreakPoint
        // Chân sóng W1 về lại SL (Entry) → phá cấu trúc → cancel
        pendingState := 0
    else if not na(pendW1Peak) and close < pendW1Peak
        // Close vượt W1 trough → Confirm! → move to retest phase
        pendingState := -2
        waveConfBar  := bar_index
        waveConfHigh := high
        waveConfLow  := low

// -- New raw break → start tracking --
// SH = sh0 (đỉnh cũ = Entry)
// W1 peak = highest high from break candle until first bearish candle
if rawBreakUp and pendingState != 2
    // Terminate old signal's lines when new tracking starts
    f_terminateLines()
    f_clearPending()
    f_clearBoxes()
    activeEntryLine  := na
    activeSLLine     := na
    activeTPLine     := na
    activeEntryPrice := na
    activeTPPrice    := na
    activeSignalDir  := 0
    pendEntryLine    := na
    pendW1Line       := na
    pendPhaseLabel   := na
    activeRiskBox    := na
    activeRewardBox  := na
    // --- Find W1 peak: highest high from break candle until first bearish ---
    // Also track lowest low during W1 impulse for W1 Trough initialization
    float _w1Peak    = na
    int   _w1Bar     = na   // bar_index of W1 peak (absolute)
    int   _w1Lookback = na  // lookback from current bar to W1 bar
    float _w1TroughInit = na // lowest low from break candle to W1 bar
    bool  _foundBreak = false
    int _scanFrom = bar_index - sh0_idx   // sh0 lookback
    for i = _scanFrom to 0
        float _cl = close[i]
        float _op = open[i]
        float _hi = high[i]
        float _lo = low[i]
        if not _foundBreak
            if _cl > sh0
                _foundBreak  := true
                _w1Peak      := _hi
                _w1Bar       := bar_index - i
                _w1Lookback  := i
                _w1TroughInit := _lo
        else
            if _hi > _w1Peak
                _w1Peak     := _hi
                _w1Bar      := bar_index - i
                _w1Lookback := i
            if na(_w1TroughInit) or _lo < _w1TroughInit
                _w1TroughInit := _lo
            if _cl < _op   // First bearish candle → end of W1 impulse
                break
    // If W1 peak not found, skip
    if not na(_w1Peak)
        pendingState   := 1
        pendBreakPoint := sh0       // SH = Entry level
        pendW1Peak     := _w1Peak   // W1 peak = first impulse wave high
        pendW1Trough   := _w1TroughInit  // Init with lowest low during W1 impulse
        pendSL         := slBeforeSH
        pendSL_idx     := slBeforeSH_idx
        pendBreak_idx  := sh0_idx   // Entry line starts from sh0
        // Retroactive scan: from W1 bar + 1 to current bar
        // Supports Phase 1→2 continuation (confirm then retest in same scan)
        int _retroFrom = math.max(_w1Lookback - 1, 0)  // w1_bar + 1 as lookback
        for i = _retroFrom to 0
            float rHigh  = high[i]
            float rLow   = low[i]
            float rClose = close[i]
            if pendingState == 1
                // Phase 1: wait for confirm
                if na(pendW1Trough) or rLow < pendW1Trough
                    pendW1Trough := rLow
                if not na(pendSL) and rLow <= pendSL
                    pendingState := 0
                    break
                if rLow <= pendBreakPoint
                    pendingState := 0
                    break
                if rClose > pendW1Peak
                    pendingState := 2
                    waveConfBar  := bar_index - i
                    waveConfHigh := rHigh
                    waveConfLow  := rLow
                    continue  // Don't break! Continue to Phase 2 check
            if pendingState == 2
                // Phase 2: wait for retest entry
                if not na(pendSL) and rLow <= pendSL
                    pendingState := 0
                    break
                if rLow <= pendBreakPoint
                    // Retest Entry → BUY signal (within retro scan)
                    confirmedBuy  := true
                    confEntry     := pendBreakPoint
                    confSL        := pendSL
                    confSL_idx    := pendSL_idx
                    confBreak_idx := pendBreak_idx
                    confBreakPt   := pendBreakPoint
                    confW1Peak    := pendW1Peak
                    confWaveBar   := waveConfBar
                    confWaveHigh  := waveConfHigh
                    confWaveLow   := waveConfLow
                    pendingState  := 0
                    break
                if not na(pendW1Trough) and rLow <= pendW1Trough
                    pendingState := 0
                    break
            if pendingState == 0
                break

// SL (đáy cũ = Entry), W1 trough = first impulse wave low
if rawBreakDown and pendingState != -2
    // Terminate old signal's lines when new tracking starts
    f_terminateLines()
    f_clearPending()
    f_clearBoxes()
    activeEntryLine  := na
    activeSLLine     := na
    activeTPLine     := na
    activeEntryPrice := na
    activeTPPrice    := na
    activeSignalDir  := 0
    pendEntryLine    := na
    pendW1Line       := na
    pendPhaseLabel   := na
    activeRiskBox    := na
    activeRewardBox  := na
    // --- Find W1 trough: lowest low from break candle until first bullish ---
    // Also track highest high during W1 impulse for W1 Trough initialization (SELL)
    float _w1Trough   = na
    int   _w1BarSell  = na   // bar_index of W1 trough (absolute)
    int   _w1LBSell   = na   // lookback from current bar to W1 bar
    float _w1TroughInitSell = na // highest high from break candle to W1 bar (SELL)
    bool  _foundBrkDn = false
    int _scanFromDn = bar_index - sl0_idx   // sl0 lookback
    for i = _scanFromDn to 0
        float _cl = close[i]
        float _op = open[i]
        float _lo = low[i]
        float _hi = high[i]
        if not _foundBrkDn
            if _cl < sl0
                _foundBrkDn  := true
                _w1Trough    := _lo
                _w1BarSell   := bar_index - i
                _w1LBSell    := i
                _w1TroughInitSell := _hi
        else
            if _lo < _w1Trough
                _w1Trough    := _lo
                _w1BarSell   := bar_index - i
                _w1LBSell    := i
            if na(_w1TroughInitSell) or _hi > _w1TroughInitSell
                _w1TroughInitSell := _hi
            if _cl > _op   // First bullish candle → end of W1 impulse
                break
    // If W1 trough not found, skip
    if not na(_w1Trough)
        pendingState   := -1
        pendBreakPoint := sl0       // SL = Entry level
        pendW1Peak     := _w1Trough // W1 trough = mốc cần vượt (xuống)
        pendW1Trough   := _w1TroughInitSell  // Init with highest high during W1 impulse
        pendSL         := shBeforeSL
        pendSL_idx     := shBeforeSL_idx
        pendBreak_idx  := sl0_idx   // Entry line starts from sl0
        // Retroactive scan: from W1 bar + 1 to current bar
        int _retroFromSell = math.max(_w1LBSell - 1, 0)  // w1_bar + 1 as lookback
        for i = _retroFromSell to 0
            float rHigh  = high[i]
            float rLow   = low[i]
            float rClose = close[i]
            if pendingState == -1
                // Phase 1: wait for confirm SELL
                if na(pendW1Trough) or rHigh > pendW1Trough
                    pendW1Trough := rHigh
                if not na(pendSL) and rHigh >= pendSL
                    pendingState := 0
                    break
                if rHigh >= pendBreakPoint
                    pendingState := 0
                    break
                if rClose < pendW1Peak
                    pendingState := -2
                    waveConfBar  := bar_index - i
                    waveConfHigh := rHigh
                    waveConfLow  := rLow
                    continue  // Don't break! Continue to Phase 2 check
            if pendingState == -2
                // Phase 2: wait for retest entry SELL
                if not na(pendSL) and rHigh >= pendSL
                    pendingState := 0
                    break
                if rHigh >= pendBreakPoint
                    // Retest Entry → SELL signal (within retro scan)
                    confirmedSell := true
                    confEntry     := pendBreakPoint
                    confSL        := pendSL
                    confSL_idx    := pendSL_idx
                    confBreak_idx := pendBreak_idx
                    confBreakPt   := pendBreakPoint
                    confW1Peak    := pendW1Peak
                    confWaveBar   := waveConfBar
                    confWaveHigh  := waveConfHigh
                    confWaveLow   := waveConfLow
                    pendingState  := 0
                    break
                if not na(pendW1Trough) and rHigh >= pendW1Trough
                    pendingState := 0
                    break
            if pendingState == 0
                break

// ============================================================================
// D) PLOTTING / UI
// ============================================================================

// -- Swing Points --
plotshape(showSwings and not na(swingHigh), title = "Swing High",
     style = shape.triangledown, location = location.abovebar,
     color = colSwingHigh, offset = -pivotLen, size = size.tiny)

plotshape(showSwings and not na(swingLow), title = "Swing Low",
     style = shape.triangleup, location = location.belowbar,
     color = colSwingLow, offset = -pivotLen, size = size.tiny)

// -- Confirmed BUY Retest --
if confirmedBuy
    // TP = high of Confirm Break candle
    float _tp = confWaveHigh
    float _risk = math.abs(confEntry - confSL)
    float _reward = math.abs(_tp - confEntry)
    float _rr = _risk > 0 ? _reward / _risk : 0

    if showBreakLine
        f_terminateLines()
        f_clearPending()
        f_clearBoxes()
        pendEntryLine  := na
        pendW1Line     := na
        pendPhaseLabel := na

        activeEntryLine := line.new(confBreak_idx, confEntry, bar_index, confEntry,
             xloc = xloc.bar_index, color = colEntryBuy,
             style = line.style_dashed, width = 1)
        activeSLLine := line.new(confSL_idx, confSL, bar_index, confSL,
             xloc = xloc.bar_index, color = colSL,
             style = line.style_dashed, width = 1)
        activeTPLine := line.new(confBreak_idx, _tp, bar_index, _tp,
             xloc = xloc.bar_index, color = colTP,
             style = line.style_dashed, width = 1)

        // Signal bar = retest bar → lines are fixed, don't extend
        activeEntryLine  := na
        activeSLLine     := na
        activeTPLine     := na
        activeEntryPrice := na
        activeTPPrice    := na
        activeSignalDir  := 0
        activeRiskBox    := na
        activeRewardBox  := na

        // Labels
        label.new(bar_index, confEntry, "Entry",
             xloc = xloc.bar_index, yloc = yloc.price,
             style = label.style_label_left, color = colEntryBuy,
             textcolor = color.white, size = size.tiny)
        label.new(bar_index, confSL, "SL",
             xloc = xloc.bar_index, yloc = yloc.price,
             style = label.style_label_left, color = colSL,
             textcolor = color.white, size = size.tiny)
        label.new(bar_index, _tp, str.format("TP ({0,number,#.#}R)", _rr),
             xloc = xloc.bar_index, yloc = yloc.price,
             style = label.style_label_left, color = colTP,
             textcolor = color.white, size = size.tiny)

    // Risk/Reward boxes
    if showBoxes
        box.new(confBreak_idx, confEntry, bar_index, confSL,
             xloc = xloc.bar_index, border_color = color.new(colSL, 60),
             bgcolor = color.new(colSL, 90), border_width = 0)
        box.new(confBreak_idx, _tp, bar_index, confEntry,
             xloc = xloc.bar_index, border_color = color.new(colTP, 60),
             bgcolor = color.new(colTP, 90), border_width = 0)

    if showBreakLabel
        label.new(confWaveBar, confWaveHigh, "▲ Confirm Break",
             xloc = xloc.bar_index, yloc = yloc.price,
             style = label.style_label_down, color = colBreakUp,
             textcolor = color.white, size = size.tiny)

// -- Confirmed SELL Retest --
if confirmedSell
    // TP = low of Confirm Break candle
    float _tp = confWaveLow
    float _risk = math.abs(confSL - confEntry)
    float _reward = math.abs(confEntry - _tp)
    float _rr = _risk > 0 ? _reward / _risk : 0

    if showBreakLine
        f_terminateLines()
        f_clearPending()
        f_clearBoxes()
        pendEntryLine  := na
        pendW1Line     := na
        pendPhaseLabel := na

        activeEntryLine := line.new(confBreak_idx, confEntry, bar_index, confEntry,
             xloc = xloc.bar_index, color = colEntrySell,
             style = line.style_dashed, width = 1)
        activeSLLine := line.new(confSL_idx, confSL, bar_index, confSL,
             xloc = xloc.bar_index, color = colSL,
             style = line.style_dashed, width = 1)
        activeTPLine := line.new(confBreak_idx, _tp, bar_index, _tp,
             xloc = xloc.bar_index, color = colTP,
             style = line.style_dashed, width = 1)

        // Signal bar = retest bar → lines are fixed, don't extend
        activeEntryLine  := na
        activeSLLine     := na
        activeTPLine     := na
        activeEntryPrice := na
        activeTPPrice    := na
        activeSignalDir  := 0
        activeRiskBox    := na
        activeRewardBox  := na

        // Labels
        label.new(bar_index, confEntry, "Entry",
             xloc = xloc.bar_index, yloc = yloc.price,
             style = label.style_label_left, color = colEntrySell,
             textcolor = color.white, size = size.tiny)
        label.new(bar_index, confSL, "SL",
             xloc = xloc.bar_index, yloc = yloc.price,
             style = label.style_label_left, color = colSL,
             textcolor = color.white, size = size.tiny)
        label.new(bar_index, _tp, str.format("TP ({0,number,#.#}R)", _rr),
             xloc = xloc.bar_index, yloc = yloc.price,
             style = label.style_label_left, color = colTP,
             textcolor = color.white, size = size.tiny)

    // Risk/Reward boxes
    if showBoxes
        box.new(confBreak_idx, confSL, bar_index, confEntry,
             xloc = xloc.bar_index, border_color = color.new(colSL, 60),
             bgcolor = color.new(colSL, 90), border_width = 0)
        box.new(confBreak_idx, confEntry, bar_index, _tp,
             xloc = xloc.bar_index, border_color = color.new(colTP, 60),
             bgcolor = color.new(colTP, 90), border_width = 0)

    if showBreakLabel
        label.new(confWaveBar, confWaveLow, "▼ Confirm Break",
             xloc = xloc.bar_index, yloc = yloc.price,
             style = label.style_label_up, color = colBreakDown,
             textcolor = color.white, size = size.tiny)

// -- Extend active lines to the right every bar --
if not na(activeEntryLine)
    line.set_x2(activeEntryLine, bar_index)
if not na(activeSLLine)
    line.set_x2(activeSLLine, bar_index)
if not na(activeTPLine)
    line.set_x2(activeTPLine, bar_index)

// -- Pending State Visualization --
if showPending and pendingState != 0
    f_clearPending()
    bool _isBuy = pendingState > 0
    string _phaseText = math.abs(pendingState) == 1 ? "Phase 1" : "Phase 2"
    color _pendColor = _isBuy ? color.new(colEntryBuy, 50) : color.new(colEntrySell, 50)
    color _w1Color   = color.new(colTP, 50)

    // Entry level line (dotted)
    if not na(pendBreakPoint) and not na(pendBreak_idx)
        pendEntryLine := line.new(pendBreak_idx, pendBreakPoint, bar_index, pendBreakPoint,
             xloc = xloc.bar_index, color = _pendColor,
             style = line.style_dotted, width = 1)

    // W1 Peak/Trough line (dotted)
    if not na(pendW1Peak)
        int _w1Start = not na(pendBreak_idx) ? pendBreak_idx : bar_index - 20
        pendW1Line := line.new(_w1Start, pendW1Peak, bar_index, pendW1Peak,
             xloc = xloc.bar_index, color = _w1Color,
             style = line.style_dotted, width = 1)

    // Phase label
    pendPhaseLabel := label.new(bar_index, pendBreakPoint,
         _phaseText + (_isBuy ? " BUY" : " SELL"),
         xloc = xloc.bar_index, yloc = yloc.price,
         style = _isBuy ? label.style_label_up : label.style_label_down,
         color = color.new(_pendColor, 30),
         textcolor = color.white, size = size.tiny)
else if showPending and pendingState == 0
    f_clearPending()
    pendEntryLine  := na
    pendW1Line     := na
    pendPhaseLabel := na

// ============================================================================
// E) ALERTS
// ============================================================================
alertcondition(confirmedBuy,  title = "BUY Signal",
     message = "MST Medio BUY | Entry={{close}} | {{ticker}} {{interval}}")
alertcondition(confirmedSell, title = "SELL Signal",
     message = "MST Medio SELL | Entry={{close}} | {{ticker}} {{interval}}")
alertcondition(confirmedBuy or confirmedSell, title = "Any Signal",
     message = "MST Medio Signal | {{ticker}} {{interval}}")
