//@version=6
// ─────────────────────────────────────────────────────────────────────────────
// Indicator : MST Medio
// Version   : v0.3
// Author    : MTS
// Based on  : PA Break v0.7.0
// Purpose   : Detect HH/LL breakouts → wait for CLOSE vượt W1 peak (confirm)
//             → then wait for RETEST at SH/SL (Entry = đỉnh/đáy cũ).
//             SH = sh0 (đỉnh cũ bị phá).
//             W1 peak = highest high from break candle until first bearish candle
//             (NOT sh1 pivot high — W1 = first impulse wave only).
// Notes     : Works on all timeframes. Non-repainting (uses confirmed pivots).
//             Break = HH/LL → close vượt W1 → retest → entry signal.
// ─────────────────────────────────────────────────────────────────────────────
indicator(
     title      = "MST Medio v0.3",
     shorttitle = "MST Medio",
     overlay    = true,
     max_labels_count = 500,
     max_lines_count  = 500,
     max_boxes_count  = 500
)

// ============================================================================
// A) INPUTS
// ============================================================================
string GRP_CORE  = "Core"
string GRP_STYLE = "Style"

pivotLen   = input.int(5,   "Pivot Lookback", minval = 2, maxval = 50, group = GRP_CORE,
             tooltip = "Number of bars left/right to confirm a Swing High/Low.")
breakMult  = input.float(0.25, "Break Strength (x Swing Range)", minval = 0, step = 0.25, group = GRP_CORE,
             tooltip = "Break distance must be >= breakMult x previous swing range. 0 = filter OFF.")
impulseMult = input.float(1.5, "Impulse Body (x Avg Body)", minval = 0, step = 0.25, group = GRP_CORE,
             tooltip = "Nến break phải có thân >= impulseMult x body trung bình. 0 = OFF.")

// Style
showSwings     = input.bool(false, "Show Swing Points",     group = GRP_STYLE)
showBreakLabel = input.bool(true,  "Show Break Labels",     group = GRP_STYLE)
showBreakLine  = input.bool(true,  "Show Break Lines",      group = GRP_STYLE)

colBreakUp   = input.color(color.new(color.green, 0),  "Break UP Label",     group = GRP_STYLE)
colBreakDown = input.color(color.new(color.red, 0),    "Break DOWN Label",   group = GRP_STYLE)
colEntryBuy  = input.color(color.new(color.blue, 0),   "Entry Buy Color",    group = GRP_STYLE)
colEntrySell = input.color(color.new(#ff69b4, 0),      "Entry Sell Color",   group = GRP_STYLE)
colSL        = input.color(color.new(color.yellow, 0), "SL Color",           group = GRP_STYLE)
colSwingHigh = input.color(color.new(color.orange, 40), "Swing High Color",  group = GRP_STYLE)
colSwingLow  = input.color(color.new(color.blue, 40),   "Swing Low Color",   group = GRP_STYLE)

// ============================================================================
// B) CORE LOGIC
// ============================================================================

// -- Swing Detection --
swingHigh = ta.pivothigh(high, pivotLen, pivotLen)
swingLow  = ta.pivotlow(low,  pivotLen, pivotLen)

// -- Track Swing History --
var float sh1     = na      // Most recent Swing High
var float sh0     = na      // Previous Swing High
var int   sh1_idx = na
var int   sh0_idx = na

var float sl1     = na      // Most recent Swing Low
var float sl0     = na      // Previous Swing Low
var int   sl1_idx = na
var int   sl0_idx = na

var float slBeforeSH     = na   // Last SL before the most recent SH
var int   slBeforeSH_idx = na
var float shBeforeSL     = na   // Last SH before the most recent SL
var int   shBeforeSL_idx = na


if not na(swingLow)
    sl0     := sl1
    sl0_idx := sl1_idx
    sl1     := swingLow
    sl1_idx := bar_index - pivotLen

if not na(swingHigh)
    slBeforeSH     := sl1
    slBeforeSH_idx := sl1_idx
    sh0     := sh1
    sh0_idx := sh1_idx
    sh1     := swingHigh
    sh1_idx := bar_index - pivotLen

if not na(swingLow)
    shBeforeSL     := sh1
    shBeforeSL_idx := sh1_idx

// -- HH / LL Detection --
bool isNewHH = not na(swingHigh) and not na(sh0) and sh1 > sh0
bool isNewLL = not na(swingLow)  and not na(sl0) and sl1 < sl0

// -- Impulse Body Filter (nến break phải có thân dài) --
// Tìm nến đầu tiên CLOSE vượt đỉnh/đáy cũ, check body >= impulseMult × avg
float _avgBody = ta.sma(math.abs(close - open), 20)

if isNewHH and impulseMult > 0
    int _fromBar = bar_index - sh0_idx   // sh0 position (lookback)
    int _toBar   = pivotLen               // sh1 position (lookback)
    bool _found  = false
    for i = _fromBar to _toBar
        if close[i] > sh0
            // This is the FIRST candle closing above → must be impulse
            _found := math.abs(close[i] - open[i]) >= impulseMult * _avgBody
            break  // Only check the FIRST one
    if not _found
        isNewHH := false

if isNewLL and impulseMult > 0
    int _fromBar = bar_index - sl0_idx
    int _toBar   = pivotLen
    bool _found  = false
    for i = _fromBar to _toBar
        if close[i] < sl0
            _found := math.abs(close[i] - open[i]) >= impulseMult * _avgBody
            break  // Only check the FIRST one
    if not _found
        isNewLL := false

// -- Break Strength Filter (optional, default OFF) --
bool rawBreakUp  = false
bool rawBreakDown = false

if isNewHH and not na(slBeforeSH)
    if breakMult <= 0
        rawBreakUp := true
    else
        float swR = sh0 - slBeforeSH
        float brD = sh1 - sh0
        if swR > 0 and brD >= swR * breakMult
            rawBreakUp := true

if isNewLL and not na(shBeforeSL)
    if breakMult <= 0
        rawBreakDown := true
    else
        float swR = shBeforeSL - sl0
        float brD = sl0 - sl1
        if swR > 0 and brD >= swR * breakMult
            rawBreakDown := true

// ============================================================================
// C) 3-PHASE CONFIRMATION: BREAK → CONFIRM → RETEST ENTRY
// ============================================================================
// Phương pháp:
//   1. Tìm SH (đỉnh cũ = sh0). Sau SH có break lớn tạo HH (sh1 > sh0).
//      → W1 peak = highest high from break candle until first bearish candle
//        (sóng impulse đầu tiên, KHÔNG phải sh1 pivot high)
//      → sh0 = SH = Entry level
//   2. Phase 1: Chờ giá pullback rồi CLOSE vượt W1 peak → Confirm
//      → Cancel nếu chân sóng W1 (low) chạm SH (sh0) → phá cấu trúc
//      → Cancel nếu giá chạm SL
//   3. Phase 2: Chờ retest tại SH (sh0) → Entry
//      → Cancel nếu giá chạm SL
//      → Cancel nếu giá break W1 trough
//
// SELL: ngược lại — SL (đáy cũ = sl0), LL, W1 trough = first impulse wave low
//
// States:
//   0 = idle
//   1 = phase 1: chờ confirm BUY (close > W1 peak)
//   2 = phase 2: chờ retest BUY (price <= Entry)
//  -1 = phase 1: chờ confirm SELL (close < W1 trough)
//  -2 = phase 2: chờ retest SELL (price >= Entry)

var int   pendingState   = 0
var float pendBreakPoint = na   // SH (sh0) or SL (sl0) = Entry level
var float pendW1Peak     = na   // W1 peak (BUY) or W1 trough (SELL) = first impulse wave extreme
var float pendW1Trough   = na   // Đáy W1 (BUY) or Đỉnh W1 (SELL) — dùng để terminate lines
var float pendSL         = na   // Stop Loss level
var int   pendSL_idx     = na
var int   pendBreak_idx  = na

// Confirm tracking
var int   waveConfBar    = na   // bar_index when confirmed
var float waveConfHigh   = na   // high of confirm bar
var float waveConfLow    = na   // low of confirm bar

// Candle direction
bool isBullish = close >= open

// Confirmed signals (for plotting and alerts)
bool confirmedBuy  = false
bool confirmedSell = false

// Save confirmed values for drawing
float confEntry      = na
float confSL         = na
int   confSL_idx     = na
int   confBreak_idx  = na
float confBreakPt    = na
int   confWaveBar    = na  // bar where wave was confirmed
float confWaveHigh   = na  // high of wave confirm bar
float confWaveLow    = na  // low of wave confirm bar

// -- Persistent Lines (declared early for f_terminateLines) --
var line  activeEntryLine  = na
var line  activeSLLine     = na
var float activeEntryPrice = na   // Entry price of last confirmed signal
var int   activeSignalDir  = 0    // 1 = BUY, -1 = SELL

f_terminateLines() =>
    if not na(activeEntryLine)
        line.set_x2(activeEntryLine, bar_index)
    if not na(activeSLLine)
        line.set_x2(activeSLLine, bar_index)

// -- Post-signal Entry touch → terminate lines --
// Nến bất kỳ sau tín hiệu chạm Entry → kết thúc đường
if not na(activeEntryLine) and not na(activeEntryPrice) and activeSignalDir != 0
    bool _touchEntry = (activeSignalDir == 1 and low <= activeEntryPrice) or (activeSignalDir == -1 and high >= activeEntryPrice)
    if _touchEntry
        f_terminateLines()
        activeEntryLine  := na
        activeSLLine     := na
        activeEntryPrice := na
        activeSignalDir  := 0

// -- Phase 2: Retest at Entry (sh0 for BUY, sl0 for SELL) --
if pendingState == 2 and not na(pendBreakPoint)
    // SL invalidation
    if not na(pendSL) and low <= pendSL
        pendingState := 0
        f_terminateLines()
        activeEntryLine  := na
        activeSLLine     := na
        activeEntryPrice := na
        activeSignalDir  := 0
    else if low <= pendBreakPoint
        // Retest Entry → BUY signal!
        confirmedBuy  := true
        confEntry     := pendBreakPoint
        confSL        := pendSL
        confSL_idx    := pendSL_idx
        confBreak_idx := pendBreak_idx
        confBreakPt   := pendBreakPoint
        confWaveBar   := waveConfBar
        confWaveHigh  := waveConfHigh
        confWaveLow   := waveConfLow
        pendingState  := 0
    // W1 trough invalidation — low chạm dưới chân sóng W1 → kết thúc
    else if not na(pendW1Trough) and low <= pendW1Trough
        pendingState := 0
        f_terminateLines()
        activeEntryLine  := na
        activeSLLine     := na
        activeEntryPrice := na
        activeSignalDir  := 0

if pendingState == -2 and not na(pendBreakPoint)
    // SL invalidation
    if not na(pendSL) and high >= pendSL
        pendingState := 0
        f_terminateLines()
        activeEntryLine  := na
        activeSLLine     := na
        activeEntryPrice := na
        activeSignalDir  := 0
    else if high >= pendBreakPoint
        // Retest Entry → SELL signal!
        confirmedSell := true
        confEntry     := pendBreakPoint
        confSL        := pendSL
        confSL_idx    := pendSL_idx
        confBreak_idx := pendBreak_idx
        confBreakPt   := pendBreakPoint
        confWaveBar   := waveConfBar
        confWaveHigh  := waveConfHigh
        confWaveLow   := waveConfLow
        pendingState  := 0
    // W1 peak invalidation — high chạm trên đỉnh W1 (SELL) → kết thúc
    else if not na(pendW1Trough) and high >= pendW1Trough
        pendingState := 0
        f_terminateLines()
        activeEntryLine  := na
        activeSLLine     := na
        activeEntryPrice := na
        activeSignalDir  := 0

// -- Phase 1: Wait for CLOSE > W1 peak (BUY) or CLOSE < W1 trough (SELL) --
if pendingState == 1
    // BUY: chờ close > W1 peak (sh1)
    // Track đáy W1 (lowest low từ break đến confirm)
    if na(pendW1Trough) or low < pendW1Trough
        pendW1Trough := low
    if not na(pendSL) and low <= pendSL
        // SL hit → cancel
        pendingState := 0
    else if not na(pendBreakPoint) and low <= pendBreakPoint
        // Chân sóng W1 về lại SH → phá cấu trúc → cancel
        pendingState := 0
    else if not na(pendW1Peak) and close > pendW1Peak
        // Close vượt W1 peak → Confirm! → move to retest phase
        pendingState := 2
        waveConfBar  := bar_index
        waveConfHigh := high
        waveConfLow  := low

if pendingState == -1
    // SELL: chờ close < W1 trough (sl1)
    // Track đỉnh W1 (highest high từ break đến confirm)
    if na(pendW1Trough) or high > pendW1Trough
        pendW1Trough := high
    if not na(pendSL) and high >= pendSL
        // SL hit → cancel
        pendingState := 0
    else if not na(pendBreakPoint) and high >= pendBreakPoint
        // Chân sóng W1 về lại SL (Entry) → phá cấu trúc → cancel
        pendingState := 0
    else if not na(pendW1Peak) and close < pendW1Peak
        // Close vượt W1 trough → Confirm! → move to retest phase
        pendingState := -2
        waveConfBar  := bar_index
        waveConfHigh := high
        waveConfLow  := low

// -- New raw break → start tracking --
// SH = sh0 (đỉnh cũ = Entry)
// W1 peak = highest high from break candle until first bearish candle
if rawBreakUp and pendingState != 2
    // Terminate old signal's lines when new tracking starts
    f_terminateLines()
    activeEntryLine  := na
    activeSLLine     := na
    activeEntryPrice := na
    activeSignalDir  := 0
    // --- Find W1 peak: highest high from break candle until first bearish ---
    // Also track lowest low during W1 impulse for W1 Trough initialization
    float _w1Peak    = na
    int   _w1Bar     = na   // bar_index of W1 peak (absolute)
    int   _w1Lookback = na  // lookback from current bar to W1 bar
    float _w1TroughInit = na // lowest low from break candle to W1 bar
    bool  _foundBreak = false
    int _scanFrom = bar_index - sh0_idx   // sh0 lookback
    for i = _scanFrom to 0
        float _cl = close[i]
        float _op = open[i]
        float _hi = high[i]
        float _lo = low[i]
        if not _foundBreak
            if _cl > sh0
                _foundBreak  := true
                _w1Peak      := _hi
                _w1Bar       := bar_index - i
                _w1Lookback  := i
                _w1TroughInit := _lo
        else
            if _hi > _w1Peak
                _w1Peak     := _hi
                _w1Bar      := bar_index - i
                _w1Lookback := i
            if na(_w1TroughInit) or _lo < _w1TroughInit
                _w1TroughInit := _lo
            if _cl < _op   // First bearish candle → end of W1 impulse
                break
    // If W1 peak not found, skip
    if not na(_w1Peak)
        pendingState   := 1
        pendBreakPoint := sh0       // SH = Entry level
        pendW1Peak     := _w1Peak   // W1 peak = first impulse wave high
        pendW1Trough   := _w1TroughInit  // Init with lowest low during W1 impulse
        pendSL         := slBeforeSH
        pendSL_idx     := slBeforeSH_idx
        pendBreak_idx  := sh0_idx   // Entry line starts from sh0
        // Retroactive scan: from W1 bar + 1 to current bar
        // Supports Phase 1→2 continuation (confirm then retest in same scan)
        int _retroFrom = math.max(_w1Lookback - 1, 0)  // w1_bar + 1 as lookback
        for i = _retroFrom to 0
            float rHigh  = high[i]
            float rLow   = low[i]
            float rClose = close[i]
            if pendingState == 1
                // Phase 1: wait for confirm
                if na(pendW1Trough) or rLow < pendW1Trough
                    pendW1Trough := rLow
                if not na(pendSL) and rLow <= pendSL
                    pendingState := 0
                    break
                if rLow <= pendBreakPoint
                    pendingState := 0
                    break
                if rClose > pendW1Peak
                    pendingState := 2
                    waveConfBar  := bar_index - i
                    waveConfHigh := rHigh
                    waveConfLow  := rLow
                    continue  // Don't break! Continue to Phase 2 check
            if pendingState == 2
                // Phase 2: wait for retest entry
                if not na(pendSL) and rLow <= pendSL
                    pendingState := 0
                    break
                if rLow <= pendBreakPoint
                    // Retest Entry → BUY signal (within retro scan)
                    confirmedBuy  := true
                    confEntry     := pendBreakPoint
                    confSL        := pendSL
                    confSL_idx    := pendSL_idx
                    confBreak_idx := pendBreak_idx
                    confBreakPt   := pendBreakPoint
                    confWaveBar   := waveConfBar
                    confWaveHigh  := waveConfHigh
                    confWaveLow   := waveConfLow
                    pendingState  := 0
                    break
                if not na(pendW1Trough) and rLow <= pendW1Trough
                    pendingState := 0
                    break
            if pendingState == 0
                break

// SL (đáy cũ = Entry), W1 trough = first impulse wave low
if rawBreakDown and pendingState != -2
    // Terminate old signal's lines when new tracking starts
    f_terminateLines()
    activeEntryLine  := na
    activeSLLine     := na
    activeEntryPrice := na
    activeSignalDir  := 0
    // --- Find W1 trough: lowest low from break candle until first bullish ---
    // Also track highest high during W1 impulse for W1 Trough initialization (SELL)
    float _w1Trough   = na
    int   _w1BarSell  = na   // bar_index of W1 trough (absolute)
    int   _w1LBSell   = na   // lookback from current bar to W1 bar
    float _w1TroughInitSell = na // highest high from break candle to W1 bar (SELL)
    bool  _foundBrkDn = false
    int _scanFromDn = bar_index - sl0_idx   // sl0 lookback
    for i = _scanFromDn to 0
        float _cl = close[i]
        float _op = open[i]
        float _lo = low[i]
        float _hi = high[i]
        if not _foundBrkDn
            if _cl < sl0
                _foundBrkDn  := true
                _w1Trough    := _lo
                _w1BarSell   := bar_index - i
                _w1LBSell    := i
                _w1TroughInitSell := _hi
        else
            if _lo < _w1Trough
                _w1Trough    := _lo
                _w1BarSell   := bar_index - i
                _w1LBSell    := i
            if na(_w1TroughInitSell) or _hi > _w1TroughInitSell
                _w1TroughInitSell := _hi
            if _cl > _op   // First bullish candle → end of W1 impulse
                break
    // If W1 trough not found, skip
    if not na(_w1Trough)
        pendingState   := -1
        pendBreakPoint := sl0       // SL = Entry level
        pendW1Peak     := _w1Trough // W1 trough = mốc cần vượt (xuống)
        pendW1Trough   := _w1TroughInitSell  // Init with highest high during W1 impulse
        pendSL         := shBeforeSL
        pendSL_idx     := shBeforeSL_idx
        pendBreak_idx  := sl0_idx   // Entry line starts from sl0
        // Retroactive scan: from W1 bar + 1 to current bar
        int _retroFromSell = math.max(_w1LBSell - 1, 0)  // w1_bar + 1 as lookback
        for i = _retroFromSell to 0
            float rHigh  = high[i]
            float rLow   = low[i]
            float rClose = close[i]
            if pendingState == -1
                // Phase 1: wait for confirm SELL
                if na(pendW1Trough) or rHigh > pendW1Trough
                    pendW1Trough := rHigh
                if not na(pendSL) and rHigh >= pendSL
                    pendingState := 0
                    break
                if rHigh >= pendBreakPoint
                    pendingState := 0
                    break
                if rClose < pendW1Peak
                    pendingState := -2
                    waveConfBar  := bar_index - i
                    waveConfHigh := rHigh
                    waveConfLow  := rLow
                    continue  // Don't break! Continue to Phase 2 check
            if pendingState == -2
                // Phase 2: wait for retest entry SELL
                if not na(pendSL) and rHigh >= pendSL
                    pendingState := 0
                    break
                if rHigh >= pendBreakPoint
                    // Retest Entry → SELL signal (within retro scan)
                    confirmedSell := true
                    confEntry     := pendBreakPoint
                    confSL        := pendSL
                    confSL_idx    := pendSL_idx
                    confBreak_idx := pendBreak_idx
                    confBreakPt   := pendBreakPoint
                    confWaveBar   := waveConfBar
                    confWaveHigh  := waveConfHigh
                    confWaveLow   := waveConfLow
                    pendingState  := 0
                    break
                if not na(pendW1Trough) and rHigh >= pendW1Trough
                    pendingState := 0
                    break
            if pendingState == 0
                break

// ============================================================================
// D) PLOTTING / UI
// ============================================================================

// -- Swing Points --
plotshape(showSwings and not na(swingHigh), title = "Swing High",
     style = shape.triangledown, location = location.abovebar,
     color = colSwingHigh, offset = -pivotLen, size = size.tiny)

plotshape(showSwings and not na(swingLow), title = "Swing Low",
     style = shape.triangleup, location = location.belowbar,
     color = colSwingLow, offset = -pivotLen, size = size.tiny)

// -- Confirmed BUY Retest --
if confirmedBuy
    if showBreakLine
        f_terminateLines()
        activeEntryLine := line.new(confBreak_idx, confEntry, bar_index, confEntry,
             xloc = xloc.bar_index, color = colEntryBuy,
             style = line.style_dashed, width = 1)
        activeSLLine := line.new(confSL_idx, confSL, bar_index, confSL,
             xloc = xloc.bar_index, color = colSL,
             style = line.style_dashed, width = 1)
        // Signal bar = retest bar → lines are fixed, don't extend
        activeEntryLine  := na
        activeSLLine     := na
        activeEntryPrice := na
        activeSignalDir  := 0
        // Entry & SL labels on lines
        label.new(bar_index, confEntry, "Entry",
             xloc = xloc.bar_index, yloc = yloc.price,
             style = label.style_label_left, color = colEntryBuy,
             textcolor = color.white, size = size.tiny)
        label.new(bar_index, confSL, "SL",
             xloc = xloc.bar_index, yloc = yloc.price,
             style = label.style_label_left, color = colSL,
             textcolor = color.white, size = size.tiny)

    if showBreakLabel
        label.new(confWaveBar, confWaveHigh, "Confirm Break",
             xloc = xloc.bar_index, yloc = yloc.price,
             style = label.style_label_down, color = colBreakUp,
             textcolor = color.white, size = size.tiny)

// -- Confirmed SELL Retest --
if confirmedSell
    if showBreakLine
        f_terminateLines()
        activeEntryLine := line.new(confBreak_idx, confEntry, bar_index, confEntry,
             xloc = xloc.bar_index, color = colEntrySell,
             style = line.style_dashed, width = 1)
        activeSLLine := line.new(confSL_idx, confSL, bar_index, confSL,
             xloc = xloc.bar_index, color = colSL,
             style = line.style_dashed, width = 1)
        // Signal bar = retest bar → lines are fixed, don't extend
        activeEntryLine  := na
        activeSLLine     := na
        activeEntryPrice := na
        activeSignalDir  := 0
        // Entry & SL labels on lines
        label.new(bar_index, confEntry, "Entry",
             xloc = xloc.bar_index, yloc = yloc.price,
             style = label.style_label_left, color = colEntrySell,
             textcolor = color.white, size = size.tiny)
        label.new(bar_index, confSL, "SL",
             xloc = xloc.bar_index, yloc = yloc.price,
             style = label.style_label_left, color = colSL,
             textcolor = color.white, size = size.tiny)

    if showBreakLabel
        label.new(confWaveBar, confWaveLow, "Confirm Break",
             xloc = xloc.bar_index, yloc = yloc.price,
             style = label.style_label_up, color = colBreakDown,
             textcolor = color.white, size = size.tiny)

// -- Extend active lines to the right every bar --
if not na(activeEntryLine)
    line.set_x2(activeEntryLine, bar_index)
if not na(activeSLLine)
    line.set_x2(activeSLLine, bar_index)

// ============================================================================
// E) ALERTS
// ============================================================================
alertcondition(confirmedBuy,                    title = "Wave Buy",    message = "MST Medio: BUY wave+retest entry on {{ticker}} @ {{close}}")
alertcondition(confirmedSell,                   title = "Wave Sell",   message = "MST Medio: SELL wave+retest entry on {{ticker}} @ {{close}}")
alertcondition(confirmedBuy or confirmedSell,   title = "Any Signal",  message = "MST Medio: Wave+retest entry on {{ticker}} @ {{close}}")
